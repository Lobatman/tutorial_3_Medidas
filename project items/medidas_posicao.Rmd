---
title: | 
  ![](https://i.imgur.com/SWWUQpP.png){width=500px style="display: block; margin:0 auto;"} 
  Tutorial 3: Medidas de posição e dispersão
author: "Victor Lobato dos Santos"
date: "2023-05-23"
output:
  html_document:
    highlight: haddock
    includes:
      in_header: "fever_icon.html"
    theme: flatly
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
  pdf_document:
    toc: yes
---
<div class="text-justify"> 

# Introdução ao módulo  
  
Este tutorial se trata de uma sequência de tutoriais que buscam trazer a integração da programação ao ambiente acadêmico, mais especificamente, o conhecimento do Software **R** com a disciplina de Bioestatística.  
Iremos abordar aqui, as Medidas de posição utilizadas no conteúdo de bioestatística, entre elas iremos analisar, média aritmética, ponderada, geométrica e harmônica, além do conhecimento sobre Mediana e Moda.  
  
# Medidas
  
Medidas, possuem o objetivo de sumarizar informações existentes em um conjunto de dados númericos e quantitativos.  
Podemos dividir as medidas em medidas de posição (ou tendência central), e medidas de dispersão (ou variabilidade). Dentre as medidas de dispersão, temos média, mediana e moda enquanto que, dentro das medidas de dispersão temos amplitude, variância, desvio padrão e erro padrão.  
  
# Médias  
  
## Média Aritmética  
  
Média aritmética se trata da soma de todos os elementos de uma amostra que é dividida pelo número total de elementos, sua representação se da pela equação:  
  
$$\bar{x} = \frac{\sum_{i=1}^{n}x1}{n}$$  
Na IDE do RStudio, para realizar o cálculo de média aritmética, podemos usar a função ``mean()``, onde colocamos dentro dos parénteses, a variável que compõe os dados quantificados para realizar a média. Observe o exemplo:  
  
Suponha que, você quer saber a média do peso, em kg de cinco recém-nascidos de um hospital. O peso desses recém nascidos são respecitvamente 2.5kg, 3.75kg, 2.25kg, 3.45kg, e 3.75kg.  
  
O primeiro passo, é criar um vetor para estes dados:  
```{r, message=FALSE}
peso_recem_nascidos <- c(2.5, 3.75, 2.25, 3.45, 3.75)
peso_recem_nascidos
```
Após ter sido criado um vetor com os dados, calculamos a média:  
  
```{r, message=FALSE}
mean(peso_recem_nascidos)

```
Obtivemos então que, a média aritmética do peso em kg de 5 recém nascidos de um hospita, é de 3.14kg.  
  
## Média Ponderada  
  
A média ponderada é utilizada quando se possui elementos com pesos diferentes em um conjunto de dados. A diferença da média aritmética para a média ponderada está na diferença de peso dos elementos, em uma média aritmética todos os dados apresentam pesos iguais, já na média ponderada cada elemento possui um peso determinado. 
A equação matetmática para média ponderada se da por:  

$$\bar{x} = \frac{\sum_{i=1}^{n} fixi}{\sum_{i=1}^{n} fi} = \frac{f_{i}x_{i} + f_{2}x_{2} + f_{3}x_{3} + ... f_{n}x_{n}}{f_{1} + f_{2} + f_{3} + ... f_{n}}$$
Na IDE do RStudio, podemos calcular a média ponderada através da função ``wigthted.mean()``. Com essa função, é possível especificar o peso de cada elemento existente dentro de uma amostragem. Vamos utilizar o seguinte exemplo:  
  
Suponha que em uma turma de escola, foram dadas 3 avaliações e cada uma possui pesos diferentes. Um aluno teve respectivamente as notas 80, 85 e 95 e os pesos dessas notas são respectivamente 6, 3 e 1. Como podemos saber a média ponderada dessas notas?  
  
O primeiro passo é criar um vetor para as notas e para os pesos:  
```{r, message=FALSE}
#Vetor do conjunto de dados
notas <- c(80, 85, 95)

#Vetor dos pesos 
pesos <- c(6, 3, 1)

#Calculo da média
media_ponderada <- weighted.mean(notas, pesos)

#Resultado 
media_ponderada

```
Em seguida basta utilizar a função ``weighted.mean()`` e iremos obter a média ponderada das avaliações, que teve como resultado, 83.  
  
## Média para dados agrupados em classes  
  
A média para dados agrupados em classes é feita quando os valores da variável estão agrupados em uma tabela de frequências, assim como foi visto no tutorial anterior, no exemplo da quantidade de albumina. Nesse sentido, atribuimos a fórmula:  
$$\bar{x} = \frac{\sum_{i=1}^{n} fixi}{\sum_{i=1}^{n} fi}$$
Temos que *fi* representa a frequência absoluta da classe e *xi* representa o ponto médio de cada classe, assim, *fixi* se torna a multiplicação dessas duas variáveis.  
Seguindo esta fórmula, vamos utilizar o exemplo dado no tutorial anterior:  
Suponha que, ao estudar a quantidade de albumina no plasma sanguíneo de 25 pacientes com determinada doença, um pesquisador obteve os seguintes valores: 4.2, 4.2, 4.2, 4.3, 4.3, 4.5, 4.5, 4.5, 4.5, 4.8, 4.8, 4.8, 5.0, 5.0, 5.0, 5.0, 5.3, 5.3, 5.3, 5.5, 5.6, 5.6, 5.7, 5.8, 5.8.  
A partir desses valores, vamos construir nossa tabela de frequências e descobrir a média para dados agrupados em classes.  
  
```{r, echo=TRUE, message=FALSE}
qtd_albumina <- c(5.1, 5, 5.2, 4.5, 4.8, 4.9, 5, 5.2, 5.4, 5.1, 4.9, 5, 4.9, 5.1, 5.3, 5.1, 5.1, 5.3, 4.7, 5.3, 4.7, 5.4, 5, 5.5, 5)

sort(qtd_albumina) #ordena os dados
range(qtd_albumina) #descobre o menor e o maior número

amp_total <- ceiling(max(qtd_albumina)-min(qtd_albumina))
amp_total

k <- nclass.FD(qtd_albumina)

length(qtd_albumina)
k <- ceiling((sqrt(length(qtd_albumina))))

c <- amp_total / (k-1)

infclass <- min(qtd_albumina)

supclass <- infclass + (k*c)


brk <- seq(infclass,supclass,c)

tabela_freq_albumina_t <- table(cut(qtd_albumina,breaks = brk, right = FALSE))

tabela_freq_albumina <- prop.table(tabela_freq_albumina_t)
```
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)


tabela_formatada <- data.frame(FrequenciaAbsoluta = as.vector(tabela_freq_albumina_t),
                               FrequenciaRelativa = as.vector(tabela_freq_albumina))
tabela_formatada <- cbind(Intervalo = names(tabela_freq_albumina_t), tabela_formatada)
kable(tabela_formatada, align = "c") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(bootstrap_options = "condensed") %>%
  kable_styling(bootstrap_options = "condensed")
```
A tabela acima, representa o código utilizado no exemplo do tutorial anterior, para criar uma tabela de frequências a partir da IDE base do R tendo como vetor ``tabela_freq_albumina``. Agora, a partir deste código, vamos realizar o nosso cálculo da média para dados agrupados em classes deste exemplo:  
  
```{r, message=FALSE}
#Descobrindo a média para dados agrupados
xi <- (brk[-1] + brk[-length(brk)]) / 2
xi

media_agrupada <- sum(xi * tabela_freq_albumina) /
  sum(tabela_freq_albumina)

media_agrupada
```
O resultado para a média dos dados agrupados em classes foi de 5.01. Agora, vamos entender os passos feitos para chegar até o resultado.  
 
* No vetor ``xi <- (brk[-1] + brk[-length(brk)]) / 2``, como o nome dado ao vetor diz, aqui nós descobrimos o *ponto médio* (xi) das classes. Utilizamos ``brk[-1]`` para remover o primeiro elemento do vetor ``brk``, lembrando que ``brk`` representa a sequência de valores que contém os limites de cada classe na tabela de frequência. Ao adicionar ``[-1]`` em nosso código, nós removemos o limite inferior da primeira classe.  
  
  + Ainda no primeiro vetor, seguindo nosso código, em ``brk[-length(brk)]``, nós removemos o último elemento do vetor ``brk``, ou seja, o limite superior da última classe. Removemos o limite inferior da primeira classe em ``brk[-1]`` e o limite superior em ``brk[-length(brk)]`` para separamas cada uma das classes e respectivamente encontrar o ponto médio.  
  
  + Para descobrir então o ponto médio nós somamos os dois vetores criados e dividmos por 2 (``xi <- (brk[-1] + brk[-length(brk)]) / 2``), obtendo os valores: 4.45, 4.95, 5.45, 5.95 e 6.45, respectivamente de acordo com cada classe.  
  
* No vetor ``media_agrupada <- sum(xi * tabela_freq_albumina) / sum(tabela_freq_albumina)``, foi criado para calcular a média ponderada dos pontos médios das classes (xi) e das frequências absoluta (fi) ou seja, utilizamos para calcular *fixi*. em ``xi`` nós temos o ponto médio de cada classe, e em ``tabela_freq_albumina`` nós temos as frequências relativas correspondentes a cada uma das classes da tabela. Tendo em vista isso, foi feito a multiplicação de xi e fi, compondo o código com ``(xi * tabela_freq_albumina)``.  
  + Após multiplicar *fixi*, foi feito a soma dos resultados através da função ``sum()``, portanto: ``sum(xi * tabela_freq_albumina)``.  
  
  + Por fim, foi feito a divisão desta soma pelo total das frequências relativas (fi), finalizando este vetor: ``media_agrupada <- sum(xi * tabela_freq_albumina) / sum(tabela_freq_albumina)``  
   
    
Nós calculamos a média para dados agrupados em classes, a partir de um passo a passo, utilizando técnicas básicas no R, mas é possível utilizar a função ``weighted.mean()`` para realizar este cálculo. Veja o exemplo:  
```{r, message=FALSE}
media_agrupada_1 <- weighted.mean(xi, tabela_freq_albumina)
media_agrupada_1

```
Neste exemplo, conseguimos simplificar um pouco os métodos para obter a média para dados agrupados em classes. Perceba que, ainda precisamos criar o vetor ``xi <- (brk[-1] + brk[-length(brk)]) / 2``, porém podemos simplificar a segunda parte, utilzando a função ``weighted.mean()``, adicionando o vetor ``tabela_freq_albumina`` que representa o nosso **fi**. O resultado final será o mesmo. 
  
## Média Geométrica  
  
A média geométrica geralmente é utilizada para um conjunto de dados que estão em progressão geométrica. A equação que representa esta média é:  
$$\bar{xg} = \left ( \sum_{i=1}^{n}xi \right )\tfrac{1}{n} = \sqrt{xi \cdot x2\cdot x3\cdot ...xn}$$
  
Na IDE do RStudio, podemos calcular a média geométrica, através das função ``prod()``.  
Vamos utilizar o seguinte exemplo para aplicar calcular a média geométrica no Rstudio:  
Suponha que você precise calcular a média geométrica do seguinte padrão de infecção de determinado patógeno em cinco semanas:  
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(dplyr)

semanas <- c(1, 2, 3, 4, 5)
infectados <- c(3, 9, 27, 81, 243)

tabela <- tibble(Semanas = semanas, "n° de infectados" = infectados)

library(kableExtra)
library(knitr)
kable(tabela) %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(bootstrap_options = "condensed") %>%
  row_spec(0, bold = TRUE) %>%
  row_spec(1:nrow(tabela), align = "c")
```
  
Para calcular a média geométrica, vamos primeiro utilizar o vetor dos dados referente ao número de infectados, e em seguida criar um vetor para a média geométrica:  
  
```{r, message=FALSE}
n_infectados <- c(3, 9, 27, 81, 243)

#Calculando a média Geométrica
media_geom <- prod(n_infectados)^(1/length(n_infectados))

media_geom
```
* Utilizamos a função ``prod()`` para multiplicar os números contidos dentro do vetor **n_infectados**.
  + Em seguida, utilizamos o sinal de **^** para elevar o produto de todos os dados calculados no vetor n_infectados.;
  + De acordo com a fórmula, precisamos dividir o resultado do produto por $\frac{1}{n}$, portanto, criamos a função ``(1/length(n_infectados))``, onde ``length()`` irá retornar para nós o número total de elementos contidos no vetor **n_infectados**, portanto, ao escrevermos ``1/length(n_infectados)`` estamos dividindo 1 pelo número total de dados contidos no vetor **n_infectados**  
  + Ao elevarmos a função (utilizando o sinal **^**), considerando que elevamos por $\frac{1}{n}$, a potencia se torna essencialmente uma raiz, permitindo então chegar ao resultado da nossa raiz geométrica, que foi igual a **27**  
    
## Média Móvel  
  
A média móvel é utilizada para apresentar a tendência de uma série temporal, principalmente quando se tem dados existentes represados.  
  
No RStudio, podemos fazer a média móvel a partir de um conjunto de dados, através da função ``rollmean()`` presente no pacote **zoo**.  
  
Spuonha que você precisa calcular a média móvel da qantidade de óbitos por covid em oito dias de determinado local, de acordo com a tabela:  
  
```{r, echo=FALSE, message=FALSE}
library(tidyverse)
library(dplyr)

dias <- c(1, 2, 3, 4, 5, 6, 7, 8)
mortos <- c(25, 85, 65, 45, 95, 75, 15, 35)

tabela_MM <- tibble(Dias = dias, "óbitos" = mortos)

library(kableExtra)
library(knitr)
kable(tabela_MM) %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(bootstrap_options = "condensed") %>%
  row_spec(0, bold = TRUE) %>%
  row_spec(1:nrow(tabela_MM), align = "c")

  
  

```

A partir destes dados, vamos calcular a média móvel, considerando que o vetor da tabela é ``tabela_MM``:  
```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(zoo)

#criando o vetorde dados
mortos <- c(25, 85, 65, 45, 95, 75, 15, 35)

#calculando a média móvel

media_m <- rollmean(mortos, k = 3, fill = NA)
media_m
```
  
Agora que criamos nosso vetor (``mortos``), que possui todos os dados referentes aos óbitos na tabela, precisamso calcular a média móvel.  
Para calcular a média móvel utilizamos a função ``rollmean``, disponível dentro do pacote **zoo** e, a partir disso temos ``rollmean(mortos, k = 3, fill = NA)``.  

* **x** é o vetor que possui os dados para calcular a média móvel, que nesse caso é **mortos**.  

* **k** representa o número de termos que serão incluídos na média móvel, que no nosso caso é **k = 3**, demosntrando que iremos calculera  média móvel utilizando os três termos adjacentes. Ou seja, o primeiro valor da MM representa a média dos três primeiros dados presente no vetor ``mortos``, enquanto que o segundo valor é a média do segundo, terceiro e quarto dado, subsequentemente.  

* **fill** demonstra qual valor deve ser preenchido nos primeiros elementos da MM (**k - 1**), antes que se tenha dados suficientes para realizar o cálculo da média. Por isso, aqui utilziamos ``fill = NA``, demonstrando que os dois primeiros valores da MM estarão ausentes.  
  
E por fim, temos o resultado da média móvel calculada para este exemplo, que foi: 58.33, 65, 68.33, 71.66, 61.66 e 41.66.  
O próximo passo é criar o gráfico para nossa média móvel


```{r, message=FALSE, warning=FALSE}
library(ggplot2)

#Criando um vetor para as observações com valores de 1 até o comprimento máximo

observacoes <- 1: length(mortos)

#Criando um dataframe

df <- data.frame(observacoes = 1:length(mortos), mortos, media_m)

# Plotando o gráfico
ggplot(df, aes(x = observacoes)) +
  geom_line(aes(y = mortos, color = "Óbitos")) +
  geom_line(aes(y = media_m, color = "Média Móvel")) +
  geom_point(aes(y = mortos), color = "black") +
  geom_point(aes(y = media_m), color = "red") +
  labs(title = "Óbitos por COVID-19", x = "Dias", y = "Óbitos", color = "Legenda") +
  scale_color_manual(values = c("red", "black")) +
  theme_minimal()

```
  
Para a criação do nosso gráfico, utilizamos a biblioteca **ggplot2** e criamos um vetor com nome de **observacoes** onde atribuimos a ele valores de 1 até o comprimento máximo do vetor **mortos**, tendo então:``observacoes <- 1: length(mortos)``.  
  
O próximo passo é criar um dataframe (*df*) que possui três termos principais: *observacoes*, *mortos*, e *media_m*.  

* Em *observacoes* temos a sequência dos números de 1 até o comprimento máximo (lenght) do vetor *mortos*;  

* O termo *mortos* possui os valores do vetor que criamos para calcular a média móvel, enquanto que o termo *media_m* possui os valores calculados da média móvel.  

  
Agora, para *plotar* o gráfico da média móvel, iremos utilizar a função **ggplot()**, que peretence ao pacote ggplot2 e é usada para criar um objeto gráfico. Assim temos, seguindos as linhas do código para o gráfico:  

* ``ggplot(df, aes(x - observacoes))``: **df** foi utilizado para chamar o data frame criado, ``aes(x - observacoes)`` mostra que o eixo x do gráfico está relacionado com a coluna *observacoes*.  

Nas seguintes linhas, usamos ``geom_line()`` e ``geom_point()`` para adicionar os termos geométricos ao gráfico.  

* ``geom_line(aes(y= mortos, color = "Óbitos"))``: em **geom_line()** nós adicionamos uma linha no gráfico, considerando que o eixo Y seja relacionado ao vetor *mortos*. Também, utilizamos ``color = "Óbitos"``, para representar na legenda.  

* ``geom_line(aes(y = media_m, color = "Média Móvel))``: Aqui, seguimos o mesmo processo anterior, mas agora criando uma linha no gráfico tendo como base os valores de *media_m*, e utilizando ``color = "Média Móvel"`` para indicar o que se trata na legenda, representando a série temporal da média móvel.  

* ``geom_point(aes(y = mortos), color = "black")``: utilizamos **geom_point()** para adicionar pontos no gráfico, nesse caso, tendo como base os valores referentes ao vetor *mortos*. Utilizamos ``color = "black"`` para adicionar a cor preta aos pontos.  

* ``geom_point(aes(y = media_m), color = "red")``: Seguindo o mesmo processo anterior, aqui, adicionamos os pontos no gráfico tendo como base os dados de *media_m*, e ``color = "red"`` para adicionar a cor vermelha aos pontos.  

O próximo passo para plotar o gráfico, é criar o título do gráfico e os rótulos dos eixos (x e y) do gráfico. Para isso, utilizamos a função ``labs()``, que é utilizada para definir o título ("title") de um gráfico, dessa forma temos a seguinte linha de cógito: ``labs(title = "Óbitos por COVID-19", x = "Dias", y = "Óbitos", color = "Legenda")``.  Atribuimos o nome desejado entre " " para cada um dos termos *title*, *x* e *y* que aparecerão no gráfico. 
  
Utilizamos a função ``scale_color-manual()`` que é utilizada para definir as cores da legenda. EM nosso gráfico, utilizamos a cor "red" para indicar a Média Móvel que está em vermelho, e a cor "black" para indicar os Óbitos que está representado de preto.  
  
Por último, para estilizar o gráfico de maneira mais minimalista, usamos ``theme_minimal()``. Este estilo minimalista é apenas um de vários que podem ser utilizados dentro do pacote ggplot2.
  
O resultado de todo este processo construído, é o gráfico de Média Móvel. 

## Média Harmônica  
  
A média harmônica é utilizada para casos em que existe uma discrepância evidente entre os dados. Sua fórmula é dada por: 
$$\bar{x}h = \frac{n}{\frac{1}{x1} + \frac{1}{x2} + ... \frac{1}{xn} } = \frac{n}{\sum_{i=1}^{n} \frac{1}{x1}}$$
Para calcular a média harmônica no Rstudio, vamos utilizar o seguinte exemplo:  
  
Uma população estável de 100 lontras marinhas passa por um severo gargalo e é reduzida ao tamanho populacional 12 em um único ano. Qual é a medida do tamanho populacional?

```{r, message=FALSE, echo=FALSE}
library(kableExtra)
library(knitr)

ano <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
n <- c(100, 100, 12, 10, 100, 100, 100, 100, 100, 100, 100)

tabela_lontras <- tabela_MM <- tibble(Ano = ano, n = n)

tabela_lontras %>%
  kbl() %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  row_spec(0, bold = TRUE) %>%
  row_spec(1:nrow(tabela_lontras), align = "c")



```
De acordo com o exemplo, vamos calcular a média harmônica:  
  
```{r, message=FALSE, warning=FALSE}
n <- c(100, 100, 12, 10, 100, 100, 100, 100, 100, 100, 100)

reciproco <- 1 / n

#calculando a média harmônica

media_harm <- length(n) / sum(reciproco)

media_harm
```

Para calcular a média harmônica, primeiro nós criamos um vetor com nome de ``reciproco``, e dentro dele atribuimos ``1 / n``, para calcular o reciproco de cada um dos dados contidos no vetor *n*, armazenando o resultado dentro deste vetor.  
Em seguida, criamos o vetor ``media_harm``. neste vetor criamos ``length(n) / sum(reciproco)``.  Em ``length(n)`` nós retornamos o tamanho do vetor *n* e dividimos pela soma dos valores contidos no vetor *reciproco*.  
O resultado é o valor da nossa média harmônica.  
  
# Mediana  
  
A mediana pode ser representada como um indicativo de qual valor se apresenta no meio de um conjunto de dados ordenados, ou seja, é o valor que vem precedido e sucedido do mesmo número de observações. A fórmula da mediana é presentada por:  

$$PosMd = \frac{n + 1}{2}$$
Para se calcular a mediana de dados não agrupados em classes no RStudio, podemos utilizar a função ``median()``.  
Suponha que queremos saber a mediana de um conjunto de amostra A e B. No conjunto A temos 2, 2, 4, 5, 6, 7, 8, e no conjunto B temos 3, 3, 4, 5, 7, 8, 9, 9.  
O primeiro passo é criar vetores para ambos os conjuntos.  
  
```{r, message=FALSE, warning=FALSE}

mediana_a <- c(2, 2, 4, 5, 6, 7, 8)
mediana_b <- c(3, 3, 4, 5, 7, 8, 9, 9)
```

Após criar os vetores, basta aplicar a função para ambos:  
  
```{r, message=FALSE, warning=FALSE}
median(mediana_a)
median(mediana_b)


```
Temos então que a mediana para o conjunto A é 5 e a mediana para o conjunto B é 6.  
  
## Mediana para dados agrupados em classe
  
A fórmula da mediana para dados agrupados em classe é dada por: 

$$Md = LiRmd + h \left ( \frac{\frac{n}{2} - Fant}{Fmd} \right )$$  

* **LiRmd**: É o limite inferior do intervalo que contém a mediana; 

* **h**: É a amplitude dos intervalos de classe;  

* **n**: É o tamanho da amostra;  

* **Fant**: É a frequência absoluta acumulada para baixo no intervalo anterior que contém a mediana;  

* **Fmd**: É a frequência absoluta simples no intervalo que contém a mediana.  

  
Para exemplificar o cálculo da mediana para dados agrupados em classes no RStudio, vamos utilizar o exemplo já criado sobre a quantidade de albumina.  

```{r, message=FALSE, warning=FALSE}
freq_abs_acumulada <- cumsum(tabela_freq_albumina_t)
freq_abs_acumulada
```
No exemplo da nossa tabela de frequência, construímos uma tabela de frequência a partir da quantidade de albumina no plasma sanguíneo de 25 pacientes com determinada doença. Naquele momento para nós, era interessante descobrir apenas a Frequência acumulada e a frequência relativa.  
Mas, para calcular a mediana para dados agrupados em classes, temos que descobrir o *Fant* que indica a frequência absoluta acumulada para baixo no intervalo anterior que contém a mediana. Para isso nós criamos um novo vetor com nome de **freq_abs_acumulada**.  
Neste vetor aplicamos a função ``cumsum()`` que é utilizada para calcular a soma acumulativa de elementos de determinado vetor ou tabela de frequências, tendo como resultado a frequência absoluta acumulada para baixo.
  
```{r, echo=FALSE, message=FALSE}
library(knitr)
library(kableExtra)


tabela_formatada <- data.frame("Frequencia Absoluta" = as.vector(tabela_freq_albumina_t),
                               "Frequencia Relativa" = as.vector(tabela_freq_albumina), "Frequencia Abs Baixo" = as.vector(freq_abs_acumulada))
tabela_formatada <- cbind(Intervalo = names(tabela_freq_albumina_t), tabela_formatada)
kable(tabela_formatada, align = "c") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(bootstrap_options = "condensed") %>%
  kable_styling(bootstrap_options = "condensed")

```
Agora, vamos criar os vetores e funções para calcular a classe da mediana de acordo com as funções criadas, utilizdas para criar esta tabela de frequências (ver o tutorial anterior).  

```{r, message=FALSE, warning=FALSE}
# Retomadno a tabela de frequéncias do exemplo
tabela_freq_albumina_t <- table(cut(qtd_albumina, breaks = brk, right = FALSE))

# identificando o intervalo que contém a mediana
intervalo_mediana <- which.max(tabela_freq_albumina_t)
intervalo_mediana

```
O primeiro passo é, chamar novamente o vetor que define a tabela de frequências do nosso exemplo: ``tabela_freq_albumina_t <- table(cut(qtd_albumina, breaks = brk, right = FALSE))``  
Em seguida, criamos um vetor para descobrir em qual intervalo contém a mediana, para isso temos: ``intervalo_mediana <- which.max(tabela_freq_albumina_t). Utilizamos a função **wich.max()** para encontrar o índice que contém o valor máximo  na tabela de frequências (tabela_freq_albumina_t), correspoindente ao intervalo que contém a mediana.  
  
```{r, message=FALSE, warning=FALSE}
# Encontrando o limite inferior do intervalo que contém a mediana (LiRmd)
liRmd <- as.numeric(names(tabela_freq_albumina_t)[intervalo_mediana])
liRmd
```
Para descobrir o limite inferior, uma opção rápida é visualizar o resultado do intervalo que contém a mediana e levar em consideração qual seria o limite inferior.
Porém, para criar um script que interpret isso, podemos utilizar a função ``as.numeric()`` para converter o nome do intervalo em um valor numérico, seguido de ``names()`` para conseguir os nomes dos intervalos na tabela de frequência.  
  
```{r, message=FALSE, warning=FALSE}
# Encontrando a amplitude dos intervalos de classe (h)
h <- c[1]
h
```
Para encontrar a amplitude dos intervalos de classe, criamos um vetor que chama o vetor ``c <- amp_total / (k-1)`` que utilizamos para descobrir a amplitude total da nossa tabela de frequências, no tutorial anterior.   
  
```{r, message=FALSE, warning=FALSE}
# Encontrando o tamanho da amostra (n)
n <- sum(tabela_freq_albumina_t)
n

```
O n representa o tamanho da nossa amostra, e para descobri-la, criamos um vetor com a função ``sum()``, atribuida a variável *tabela_freq_albumina_t*, para que somasse todas as frequ~encias absolutas da tabela de frequências.  
  
```{r, message=FALSE, warning=FALSE}
# Encontrando a frequência absoluta acumulada para baixo no intervalo anterior que contém a mediana (Fant)
fant <- sum(tabela_freq_albumina_t[1:(intervalo_mediana-1)])
fant
```
A frequência absoluta acumulada para baixo no intervalo anterior que contém a mediana, pode ser calculada utilizando a função ``sum()`` para somar as frequências absolutas anteriores ao intervalo que contém a mediana, e atribuimos o intervalo de ``1:(intervalo_mediana-1)`` Que nos retornará a frequência anterior.  
  
```{r, message=FALSE, warning=FALSE}
# Encontrando a frequência absoluta simples no intervalo que contém a mediana (Fmd)
fmd <- tabela_freq_albumina_t[intervalo_mediana]
fmd
```
Para indentificar a frequência absoluta simples no intervalo que contém a mediana (Fmd), nós utilizamos a variável ``tabela_freq_albumina_t`` que representa a noss atabela de frequências, juntamente da variável ``intervalo_mediana``. A partir do colchete **[]**, nós acessamos o valor que corresponde ao intervalo da mediana, em nossa tabela de frequências, uma vez que sabemos que o intervalo da mediana está em **[5,5.25)**.  
  
```{r, message=FALSE, warning=FALSE}
mediana <- 5 + h * ((n/2 - fant)/fmd)
mediana
```
O último passo é atribuir nossos resultados a fórmula de mediana para dados agrupados em classe que é: $Md = LiRmd + h \left ( \frac{\frac{n}{2} - Fant}{Fmd} \right )$ .  
Para isso, basta criar o script com base na fórmula, aplicando as variáveis criadas. A única diferença aqui, é que em LiRmd, nós substituímos por 5, que é o valor do LiRmd que já sabemos.  
O resultado deste cálculo é o valor da Mediana para dados agrupados.

# Moda  
  
A moda de um conjunto de dados, representa o valor mais frequente daquele conjunto. Para calculara a moda no RStudio, podemos fazer da seguinte forma:  
  
```{r, message=FALSE, warning=FALSE}
moda_a <- c(3, 4, 4, 5, 5, 5, 6, 7, 8)
table(moda_a)
```
Primeiro, nós criamos um vetor com o conjunto de dados que queremos descobrir a moda. O método mais fácil, porém não tão prático, dependendo do tamanho do seu conjunto de dados, é utilizar a função ``table()``, que vai criar uma tabela, com a quantidade de vezes que cada um dos números dentro do conjunto de dados é repetido.
 
```{r, message=FALSE, warning=FALSE}
moda_calculo <- subset(table(moda_a), table(moda_a) == max (table(moda_a)))
moda_calculo
```
Outro método para descobrir a moda, é utilizar a função ``subset()`` para filtrar os dados da tabela que contém a moda e a função ``table(moda_a)`` para criar uma tabela que contém os dados do nosso vetor. 

* A partir da função **subset()** e **table()**, nós utilizamos criamos nosso script. No primeiro ``table(moda_a)``, utilizamo para criar a tabela;  

* Em ``table(moda_a) == max(table(moda_a))`` nós determinamos uma condição para especificar quais linhas da tabela queremos o resultado. Utilizamos ``==`` para comparar o valor da tabela com o valor máximo da mesma tabela, a partir da função ``max()``, resultando em um valor do tipo lógico que que atribui verdadeiro (TRUE) para os valores que são iguais ao número máximo, e falso (FALSE) para aqueles que não são.  

* Com o ``subset`` que serve para filtrar os dados, conseguimos selecionar apenas os dados que queremos, a a partir da condição que criamos para apresentar apenas os valores maiores. 

Este exemplo pode ser usado tanto para modelos **unimodais**, quanto para modelos **bimodais**.  
  
## Moda para dados agrupados em classes  
  
A moda para dadosa grupados em classes é representada pela fórmula: 
  
$$Mo = li + \frac{_{\Delta1}}{_{\Delta1 + \Delta2}} * c$$

* **li** = limite inferior da classe modal;    

* $\Delta1$ = diferença entre a frequência da classe modal ea frequência da classe imedatamente anterior;  

* $\Delta2$ = diferença entre q frequência da classe modal e a frequência da classe imediatamente seguinte;    

* **c** = amplitude da classe modal.  

Para aplicar esta fórmula no R, vamos usar o exemplo utilizado na mediana para dados agrupados. Portanto, usaremos mais uma vez a tabela de frequências presente neste tutorial e no tutorial anterior, Seguindo o passo a passo abaixo:

```{r, message=FALSE, warning=FALSE}
#Retomadno a tabela de frequéncias do exemplo
tabela_freq_albumina_t <- table(cut(qtd_albumina, breaks = brk, right = FALSE))
```
Como iremos utilizar o exemplo da nossa tabela de frequências da quantidade de albumina presente no sangue de 25 pacientes, o primeiro passo é chamar o vetor desta tabela.  

```{r, message=FALSE, warning=FALSE}
#Encontrando o indice da classe da modal
indice_moda <- which.max(tabela_freq_albumina_t)
indice_moda

```
Para encontrar o indice modal, nós utilizamos a mesma função para encontrar o intervalo da mediana. A partir da função **which.max**, encontramos o índice do valor mpaximo contido na tabela.  
  
```{r, message=FALSE, warning=FALSE}
#Encontrando a frequência modal
frequencia_modal <- tabela_freq_albumina_t[indice_moda]
frequencia_modal
```
Um dos passos necessários, é criar um vetor para encontrar o indice modal, perceba que este passo também é igual ao feito no calculo da mediana para dados agrupados, a única diferença é que mudamos o vetor.  
Como a variável *indice_moda* atribui o índice da classe modal, quando criamos ``tabela_freq_albumina_t[indice_moda]``, nós estamos buscando na tabela, o valor que corresponde ao nosso *indice_moda* na tabela, retornando a frequência absoluta da classe modal. 

```{r, message=FALSE, warning=FALSE}
frequencia_anterior <- tabela_freq_albumina_t[indice_moda - 1]
frequencia_anterior
```
Encontrar a frequência anteriror, é necessária para identificar o valor de $\Delta1$ que cprres´pmde a doferemã entre a freqi]emcoa da cçasse ,pdaç e a frequência da classe imediatamente anterior.  
Portando, na função ``tabela_freq_albumina_t[indice_moda - 1]``, estamos buscando o valor que corresponde ao indice modal (*indice_moda*) e subitraindo por 1 para encontrar a classe imediatamente anterior.  
  
```{r, message=FALSE, warning=FALSE}
frequencia_seguinte <- tabela_freq_albumina_t[indice_moda + 1]
frequencia_seguinte
```
Assim como no passo anterior, encontrar criar um vetor para encontrar a frequência seguinte, é necessário para encontrar o valor de $\Delta2$ que corresponde a diferença entre a frequência da classse modal e a frequência da classe imediatamente seguinte.  
Portanto, na função ``tabela_freq_albumina_t[indice_moda + 1]``, estamos buscando o valor correspondente ao indice modal (*indice_moda*) e somando por 1 para encontrar a classe imediatamente seguinte.  

```{r, message=FALSE, warning=FALSE}
amplitude_modal <- c[1]
amplitude_modal

```
Para encontrar a amplitude modal, foi usado a mesma função para encontrar a amplitude dos intervalos de classe no exemplo da mediana para dados agrupados, em que usamos um vetor que chama a variável ``c <- amp_total / (k-1)`` criada para descobrir a amplitude total da nossa tabela de frequências, no tutorial anterior. 

```{r, message=FALSE, warning=FALSE}
delta1 <- frequencia_modal - frequencia_anterior
delta1
```
Como $\Delta1$ significa a diferença entre a frequência da classe modal (*frequencia_modal*) e a frequência da classe imediatamente anterior (*frequencia_anterior*), basta subtrair essas duas variáveis.  

```{r, message=FALSE, warning=FALSE}
delta2 <- frequencia_modal - frequencia_seguinte
delta2

```
Da mesma forma, $\Delta2$ representa a diferença entre a frequência da classe modal (*frequencia_modal*) e a frequência da classe imediatemente seguinte (*frequencia_seguinte*), portanto, subtraimos essas duas variáveis.  
  
```{r, message=FALSE, warning=FALSE}
moda_agrupada <- brk[indice_moda] + (delta1 / (delta1 + delta2)) * amplitude_modal
moda_agrupada
```
Por fim, adequamos as variáveis criadas na nossa fórmula de moda para dados agrupados em classes $Mo = li + \frac{_{\Delta1}}{_{\Delta1 + \Delta2}} * c$

Seguindo os passos da fórmula temos: 

* **brk**: É a variável que criamos no tutorial anterior, para a tabela de frequências que armazena os limites das classes em um conjunto de dados agrupados em classes (brk <- seq(infclass,supclass,c). Para dúvidas, reveja o tutorial anterior;  

* **indice_moda**: É a variável criada para conter o indice da classe modal;  

* **delta1**: É a variável que representa a diferença entre a frequência da classe modal e a frequência da classe imediatamente anterior;  

* **delta2** É a variável que representa a diferença entre a frequência da classe modal e a frequência da classe imediatamente seguinte;  

* **amplitude_modal**: É a variável que representa a amplitude modal;  
  
Tendo em vista todas essas variáveis, só precisamos substituir e adequar a fórmula. O resultado será o valor da moda para dados agrupados em classes.  

# Medidas de dispersão  
  
A partir de agora, aprenderemos a realizar calculos sobre medidas de dispersão através do Rstudio.  

## Amplitude Total  
Para descobrir uma amplitude total, basta calcularmos o valor máximo menos o valor mínimo de uma amostra.  

Vamos supor que você queira descobrir a amplitude total presente em uma tabela de dados que compõem a altura em centímetros de 3 grupos.  
Para demonstrar este exemplo, vamos carregar esta tabela: 

```{r, message=FALSE, warning=FALSE}
amplitude_exemplo <- read.csv("amplitudes_exemplo.csv", sep = ";", header = TRUE)

```

Com a tabela carregada, vamos calcular a amplitude total de uma das colunas:  

```{r, message=FALSE, warning=FALSE}
amplitude_total_B <- max(amplitude_exemplo$altura_cm_B) - min(amplitude_exemplo$altura_cm_B)

amplitude_total_B
```
Perceba que para descobrir a amplitude total de forma simples, utilizamos a função ``max``, selecionando o valor máximo coluna desejada e em seguida utilizamos o sinal de subtração e a função ``min`` para selecionar o valor mínimo da coluna desejada. O Resultado é a amplitude máxima (em centímetros), da coluna B.  

## Variância  

Em uma amostra, a variância é definida pela razão entre a soma dos quadrados dos desvios em relação a média e o número de observações menos um (grau de liberdade). A fórmula proposta para variância é:  

$$v (x) = s^2 = \frac{ \sum_{i=1}^{n}(xi - \bar{x})^2}{n -1} = \frac{\sum_{i=1}^{n} (\frac{\sum_{i=1}^{n} xi}{n})^2}{n -1}$$
No R, podemos calcular a variância a partir da função ``var``.  
Para exemplificar, vamos calcular a variância da segunda coluna de nossa tabela *amplitude_exemplo*.  

```{r, message=FALSE, warning=FALSE}
varianca_coluna_B <- var(amplitude_exemplo$altura_cm_B)

varianca_coluna_B
```
A partir da função ``var`` conseguimos calcular de maneira simples a variância e, como visto no exemplo, a variância da coluna B é igual a 13.  
  
### Variância para dados agrupados em classes  

Com base no mesmo conceito de variância, a fórmula matemática da variância para dados agrupados em classes é:  

$$s^2 \frac{\sum_{i=1}^{n} fixi^2 - \frac{(\sum_{i=1}^{n} fixi)^2}{\sum_{i=1}^{n} fi}}{\sum_{i=1}^{n} fi - 1}$$
Onde **fi** é a frequência da classe e **xi** é o ponto médio da classe.  

Para calcular a variância de dados agrupados em classes no Rstudio, vamos utilizar a tabela de frequência já citada neste e no tutorial anterior. Lembra da forma de construção da tabela de frequências que aprendemos no tutorial 2, no tópico **7.1 Passo 1: Criando e transformando os dados de uma tabela**? Iremos relembrar os passos da criação dela aqui, para calcularmos a variância.  
Portanto, vamos nos atentar aos passos de construção da tabela de frequências. Caso queira relembrar a explicação, visite o **tutorial 2: O que é estatística? Unidade, dado estatístico e variáveis**, no tópico **7.1**  

```{r, echo=TRUE, message=FALSE}
qtd_albumina <- c(5.1, 5, 5.2, 4.5, 4.8, 4.9, 5, 5.2, 5.4, 5.1, 4.9, 5, 4.9, 5.1, 5.3, 5.1, 5.1, 5.3, 4.7, 5.3, 4.7, 5.4, 5, 5.5, 5)

sort(qtd_albumina) #ordena os dados
range(qtd_albumina) #descobre o menor e o maior número

amp_total <- ceiling(max(qtd_albumina)-min(qtd_albumina))


k <- nclass.FD(qtd_albumina)

length(qtd_albumina)
k <- ceiling((sqrt(length(qtd_albumina))))

c <- amp_total / (k-1)

infclass <- min(qtd_albumina)

supclass <- infclass + (k*c)


brk <- seq(infclass,supclass,c)

tabela_freq_albumina_t <- table(cut(qtd_albumina,breaks = brk, right = FALSE))

tabela_freq_albumina <- prop.table(tabela_freq_albumina_t)
```

Seguindo os passos de criação deste exemplo de tabela de frequências, precisamos descobrir quais são os pontos médios de cada classe. Para isso, utilizaremos a seguinte função:  

```{r, message=FALSE, warning=FALSE}
ponto_medio_classes <- (brk[-1] + brk[-length(brk)]) / 2
ponto_medio_classes
```
Para calcular o ponto médio de cada uma das classes da nossa tabela, seguimos os seguintes passos:  

* **Passo 1:** Utilizamos o vetor *brk* que continha os limites das classes. Lembrando que esses limites foram calculados anteriormente utilizando a função `seq()` para criar intervalos entre o limite inferior e o limte superior.  

* **Passo 2:** a partir do código `(brk[-1] + brk[-length(brk)]) / 2` nós fizemos uma "adição vetorial" entre dois subcojuntos do nosso vetor *brk*. 

+ Em `brk[-1]` nós temos todos os elementos que estão dentro de *brk* com exceção do primeiro, que  representa o limite inferior da classe.  

+ Em `brk[-length(brk)]` nós apresentamos todos os elementos que estão presentes dentro do vetor **brk**, com exceção do último, que representa o limite superior da última classe.  

+ A partir destes dois subconjuntos, nós utilizamos o sinao de soma para somar o limite inferior e o limite superior  

* **Passo 3:** Por fim, nós dividimos por 2 (`/ 2`) para descobrir o ponto médio de cada uma das classes. Como temos um conjunto com cinco classes, este cálculo é feito para cada uma das classes.  



```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)


tabela_formatada <- data.frame(FrequenciaAbsoluta = as.vector(tabela_freq_albumina_t),
                               FrequenciaRelativa = as.vector(tabela_freq_albumina),
                               xi = as.vector(ponto_medio_classes))
tabela_formatada <- cbind(Intervalo = names(tabela_freq_albumina_t), tabela_formatada)
kable(tabela_formatada, align = "c") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(bootstrap_options = "condensed") %>%
  kable_styling(bootstrap_options = "condensed")
```

Com o entendimento de como calcular o ponto médio da classe (xi) a partir de uma tabela de frequência relativa. Podemos seguir para os próximos passos para encontrar a variância de dados agrupados em classes.  
  
Primeiro vamos calcular **fixi**:  

```{r, message=FALSE, warning=FALSE}
soma_fixi <- sum(tabela_freq_albumina_t * ponto_medio_classes)
soma_fixi

```
Neste passo, para descobrir a soma da multiplicação de **fi** e **xi**, nós utilizamos a função ``sum``, coletamos o vetor referente a nossa frequência absoluta que tem o nome de *tabela_frew_albumina_t* e multiplicamos pelo vetor referente ao ponto médio das classes, que tem como nome *ponto_medio_classes*. O resultado de 127.375 indica o a soma de nosso *fixi*.  

Em seguida, vamos calcular o quadrado da soma de fi(xi)²:

```{r, message=FALSE, warning=FALSE}
fixi_quadrado <- sum((tabela_freq_albumina_t * (ponto_medio_classes)^2))
fixi_quadrado
```
Sabendo que o primeiro passo da fórmula matemática é $\sum_{i=1}^{n}fixi^2$, para descobrir calcular o quadrado da soma de fi(xi)², seguimos de forma parecida no cálculo da soma de fixi, com a diferença de que aqui colocamos o vetor *ponto_medio_classes* elevado ao quadrado. O resultado é o valor desta soma

Agora, vamos calcular a soma de nosso fi:  

```{r, message=FALSE, warning=FALSE}
soma_fi <- sum(tabela_freq_albumina_t)
soma_fi
```
Aqui, para somar a nossa frequência absoluta da classe (fi) de todas as frequências, basta utilizar a função ``sum`` e incluir o vetor relacionado a frequência absoluta da classe.  
  
Agora, com nossos vetores *soma_fixi*, *fixi_qudrado* e *soma_fi* preparados, podemos realizar o cálculo da variância:  

```{r, message=FALSE, warning=FALSE}
variancia_classes <- (sum(fixi_quadrado - ((soma_fixi)^2 / soma_fi)) / 
                        (soma_fi - 1))
variancia_classes
```
De acordo com a fórmula para calcular a variância para dados agrupados em classes, e a fórmula criada aqui, para o Rstudio, vamos identificar os passos:  

* **Passo 1 **: Primeiro, nós abrimos nossa fórmula com a função ``sum``, pois queremos que ao final, ocorra a soma de todos os valores calculados ali dentro. Em seguida, atribuimos o vetor referente a primeira parte da fórmula matemática ($\sum_{i=1}^{n}fixi^2$) que é *fixi_quadrado* e subtraímos pelo segundo passo da fórmula.  

* **Passo 2**: O segundo passo da fórmula matemática desta variância, se refere a $\frac{(\sum_{i=1}^{n} fixi)^2}{\sum_{i=1}^{n} fi}$. Para isso, nós atribuimos o vetor *soma_fixi* que correspondia a somatória de fixi, elevamos ao quadrado (`^2`) e dividmos pelo vetor *soma_fi* que corresponde a somatória de fi.  

* **Passo 3**: Por fim, seguindo a lógica da fórmula matemática, nós dividimos o resultado dos passos anteriores por $\sum_{i=1}^{n} fi - 1$ que corresponde ao nosso vetor *soma_fi* menos (-) 1.  

O resultado de tudo isso é a variância para dados agrupados em classe, que neste exemplo foi igual a 0.06416667.  
  
## Desvio padrão  
O desvio padrão, nada mais é que a raiz quadrada da variância. Sua fórmula matemática é representada por: 

$$\sqrt{s^2} = \sqrt{\frac{ \sum_{i=1}^{n}(xi - \bar{x})^2}{n -1}} = \sqrt{\frac{\sum_{i=1}^{n} (\frac{\sum_{i=1}^{n} xi}{n})^2}{n -1}}$$
No R, podemos calcular o desvio padrão através da função ``sd``.

```{r, message=FALSE, warning=FALSE}
sd_exemplo <- c(20, 30, 40, 50, 60, 70, 80)

desvio_padrao <- sd(sd_exemplo)

desvio_padrao
```
## Desvio Padrão para dados agrupados em classes  

Para calcular o desvio padrão para dados agrupados em clases, partimos da mesma lógica do desvio padrão, porém agora aplicado a fórmula para dados agrupados em classes:  

$$s = \sqrt{\frac{\sum_{i=1}^{n} fixi^2 - \frac{(\sum_{i=1}^{n} fixi)^2}{\sum_{i=1}^{n} fi}}{\sum_{i=1}^{n} fi - 1}}$$

Perceba que, a única diferença é a adição da raiz quadratíca na fórmula que utilizamos para variância de dados agrupados em classes. Portanto, para calcular o desvio padrão aqui, só precisamos utilizar a função `sqrt` no vetor utilizado para calcular a variância dedados agrupados em classes no exemplo anterior.  

```{r, message=FALSE, warning=FALSE}
sd_classes <- sqrt(variancia_classes)

sd_classes
```
O resultado será o desvio padrão.  

## Coeficiente de Variação (CV)  

O coeficiente de variação é uma medida de dispersão relativa que expressa o desvio padrão (s) em porcentagem da média ($\bar{x}$). Temos que, quanto mais alto o CV, maior será a dispersão dos dados em relação à média (dispersão relativa alta) e, quanto mais baixo o CV, menor será a dispersão dos dados em relação a média (dispersão relativa baixa).  
A fórmula matemática do coeficiente de variação é:  

$$CV = \frac{s}{\bar{x}} * 100$$

Com base na fórmula, no RStudio, podemos calcular o coeficiente de variação a partir da divisão entre o resultado do desvio padrão, pela média, multiplicado por 100 (desvio_padrao / media) * 100.  
Vamos criar um exemplo rápido aqui de dados não agrupados, mas que também pode ser aplicado a dados agrupados, basta seguir os passos anteriores relacionados.  

```{r, message=FALSE, warning=FALSE}
cv_exemplo <- c(20, 30, 40, 50, 60, 70, 80)

media_cv <- mean(cv_exemplo)
media_cv

desvio_padrao_cv <- sd(cv_exemplo)
desvio_padrao_cv

coef_variacao <- (desvio_padrao_cv / media_cv) * 100

coef_variacao
```
Neste exemplo, nós criamos um vetor contendo 7 dados distintos, em seguida calculamos a média deste vetor através da função `mean`, calculamos o desvio padrão a partir da função `sd` e por fim, criamos uma variável onde dividimos o resultado do desvio padrão, contido no vetor *desvio_padrao_cv* pelo resultado de média resultante do vetor *media_cv* e múltiplicamos por 100. O resultado de 43.204 é o nosso coeficiente de variação.  

## Erro padrão da Média (EP)  

O erro padrão da média, é uma medida que informa a precisão em que a média da população foi estimada. Sua fórmula matemática é dada por:  

$$s(\bar{x}) = s\hat{m} = EP = \frac{s}{\sqrt{n}}$$
* $s(\bar{x})$: erro padrão;  

* s = desvio padrão; 

* n = tamanho da amostra.  

Para exemplificar, vamos utilizar o mesmo conjunto de dados do exemplo anterior:  

```{r, message=FALSE, warning=FALSE}
ep_exemplo <- c(20, 30, 40, 50, 60, 70, 80)

tamanho_amostra_ep <- length(ep_exemplo)
tamanho_amostra_ep

media_ep <- mean(ep_exemplo)
media_ep

desvio_padrao_ep <- sd(ep_exemplo)
desvio_padrao_ep

erro_padrao_media <- desvio_padrao_ep / sqrt(tamanho_amostra_ep)
erro_padrao_media
```
Neste exemplo, primeiro nós criamos um vetor contendo 7 dados distintos, em seguida utilizamos a função `length` para descobrir o tamanho da amostra (n), calculamos a média dos dados a partir da função `mean`, calculamos o desvio padrão dos dados a partir da função `sd`, e por fim, criamos uma variável dividindo o vetor referente ao resultado do desvio padrão (*desvio_padrao_ep*), pela raiz quadrada do vetor referente ao resultado do tamanho da amostra (*erro_padrao_media*). O resultado 8.164 é o nosso erro padrão da média.  

### Apresentando os dados Graficamente  

Uma forma interessante de apresentar os dados de um erro padrão da média, é através de gráficos. Para isso nós podemos criar um gráfico de barras com as linhas de erro a partir do nosso exemplo.

```{r, message=FALSE, warning=FALSE}
# Carregando a biblioteca ggplot2
library(ggplot2)

# Criando um data frame com todas as medidas
data_medidas <- data.frame(Medida = c("Media", "Desvio Padrao", "Erro Padrao da Media"),
                   Valor = c(media_ep, desvio_padrao_ep, erro_padrao_media))

# Criando o gráfico de barras com linhas de erro
plot_ep_s <- ggplot(data_medidas, aes(x = Medida, y = Valor)) +
     geom_bar(stat = "identity", fill = "#ff8c1a") +
     geom_errorbar(aes(ymin = Valor - erro_padrao_media, ymax = Valor + erro_padrao_media), width = 0.4) +
     labs(y = "Valor", title = "Comparação de Medidas") +
     theme_minimal()

plot_ep_s

```

Vamos entender os passos da criação deste gráfico:  

**Passo 1**:  

* Carregamos a biblioteca *ggplot2* que será responsável por plotar nosso gráfico;  

**Passo 2 **:  

* Criamos um data frame a partir da função `data.frame`. O objeto *Medida* contém os nomes que queremos dar aos nosso objetos, enquanto que o objeto *Valor* possui os vetores criados anteriormente para calcular a media, desvio padrão e erro padrão da média do nosso exemplo.  
  
**Passo 3**:

* Para criar o gráfico, primeiro criamos um objeto e abrimos com a função `ggplot`, em seguida adicionamos o nome do data frames que queremos criar um gráfico.  
+ A  função `aes` (aesthetic mapping) é utilizada para mapear as variáveis do nosso conjunto de dados, dessa forma, é a partir dela que definimos as configurações do gráfico;  
+ Definimos os eixos x para medida e y para valor;  
+ A partir da função `geom_bar(stat = "identity")` nós criamos as barras do gráfico de acordo com os valores presentes no data frame;  
+ Definimos a cor de nosso gráfico com a função `fill`. A cor pode ser definida de várias formas.  
+ COm a função `geom_error_bar`, nós adicionamos as linhas (barras) do erro padrão da média. Utilizamos o argumento `ymin` para especificar a extremidade inferior da linha de erro e, o argumento `ymax` para especificar a extremidade superior da linha de erro;  
  
**Extra**:  

*  O argumento `width` serve para definir a largura do nosso gráfico;  
+ O argumento `labs(y ="")` define o nome que queremos dar no eixo y; 
+ O argfumento `title` define o título que queremos apresentar no gráfico;  
+ Por fim, o argumento `theme_minimal()` é um dos muitos estilos possíveis para se aplificar em um gráfico.  
  
## Quartis e intervalo interquartífico  

Os Quartis são valores que dividem seu conjunto de dados em quatro partes.  

* Dentro do primeiro quartil (Q1), é separado o quarto (25%) referente aos dados com valores menores que os demais;  

* O segundo quartil (Q2), se refere a mediana que separa a metade dos dados com valores menores que os demais;  

* O terceiro quartil (Q3), separa o quarto (25%) de dados com valores maiores que os demais.  

Geralmente a representação dos quartis e os intervalos interquartíficos é apresentado através de um gráfico denominado **boxplot** (gráfico de caixas) e, podemos criar este gráfico de várias maneiras através do R. Vamos ver aqui, um exemplo utilizando a função `boxplot` do R Base: 

```{r, message=FALSE, warning=FALSE}
#Criando o conjunto de dados

exemplo_boxplot <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

# Criando o boxplot
boxplot(exemplo_boxplot)

```
  

De forma simples, utilizando a função `boxplot` presente no R base, nós fizemos um boxplot. Seguindo a lógica dos quartis, a linha inferior representa o primeiro quartil, a linha média representa o segundo quartil e a linha superior representa o terceiro quartil.  
Lembrando que, essa á apenas uma opção simples de criar um boxplot, existem diversas outras forma de construção do mesmo, utilizando por exemplo a biblioteca *gggplo2*.  

# Fim do módulo

Neste módulo, nós vimos as diferentes formas de calcular medidas de posição e dispersão através do Rstudio. Espero que de alguma forma, este tutorial tenha sido útil para você.  
Nos próximos tutoriais iremos nos aprofundar sobre os tipos de correlação e regressão.



</div>